

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/awesomeface.png">
  <link rel="icon" href="/img/awesomeface.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="周洪锋">
  <meta name="keywords" content="">
  
    <meta name="description" content="最近接到导师布置的一个横向任务，要利用前沿的密码学算法实现一个可搜索加密+授权加密的桌面程序。虽然密码学算法已经心里有数，但是这个程序的功能稍微有点复杂，程序设计的难度也有所提高，所以在写的时候，往往没有头绪，不知道使用怎样的设计思路来编写代码。经过一番资料的搜索后，发现了*《设计模式》这本书，这本书被广大同行所盛誉。然而图书馆的所有《设计模式》已经被借走了，于是我就找到《Head First设计">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式学习笔记">
<meta property="og:url" content="http://zhouhf.top/2024/09/08/Design_Patterns/index.html">
<meta property="og:site_name" content="周洪锋的博客">
<meta property="og:description" content="最近接到导师布置的一个横向任务，要利用前沿的密码学算法实现一个可搜索加密+授权加密的桌面程序。虽然密码学算法已经心里有数，但是这个程序的功能稍微有点复杂，程序设计的难度也有所提高，所以在写的时候，往往没有头绪，不知道使用怎样的设计思路来编写代码。经过一番资料的搜索后，发现了*《设计模式》这本书，这本书被广大同行所盛誉。然而图书馆的所有《设计模式》已经被借走了，于是我就找到《Head First设计">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/Singleton.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/uml_association.jpg">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/uml_dependency.jpg">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/uml_realize.jpg">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/uml_realize-1728011506750-13.jpg">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/uml_aggregation.jpg">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/uml_composition.jpg">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/FactoryMethod.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/AbstractFactory.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/Builder.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/Singleton.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/6477d44a8ed781508.jpg_e1080.jpg">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.drawio.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.drawio.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.drawio.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.drawio.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/image-20240911114704046.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/a77bb4adfad84fa6bcf8c5026ae37afftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.drawio.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.drawio.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.drawio.png">
<meta property="og:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.drawio.png">
<meta property="article:published_time" content="2024-09-08T14:49:43.000Z">
<meta property="article:modified_time" content="2024-11-19T11:17:56.813Z">
<meta property="article:author" content="周洪锋">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://zhouhf.top/2024/09/08/Design_Patterns/Singleton.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>设计模式学习笔记 - 周洪锋的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhouhf.top","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>周洪锋的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="设计模式学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        周洪锋
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-08 22:49" pubdate>
          2024年9月8日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          54 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">设计模式学习笔记</h1>
            
            <div class="markdown-body">
              
              <p>最近接到导师布置的一个横向任务，要利用前沿的密码学算法实现一个可搜索加密+授权加密的桌面程序。虽然密码学算法已经心里有数，但是这个程序的功能稍微有点复杂，程序设计的难度也有所提高，所以在写的时候，往往没有头绪，不知道使用怎样的设计思路来编写代码。经过一番资料的搜索后，发现了*《设计模式》<em>这本书，这本书被广大同行所盛誉。然而图书馆的所有《设计模式》已经被借走了，于是我就找到</em>《Head First设计模式》*，虽然此书难免无法像《设计模式》一样严谨，但是却大大降低了理解的难度。所以本篇文章就基于《Head First设计模式》这本书，记录一下设计模式的理论学习。如果平时的项目中有利用的相关的设计模式，可能会考虑长期更新此篇博客，或新开一篇，记录一下设计模式的实践部分。</p>
<p>说到这，还没对**设计模式（Design Patterns）**下一个定义，书上好像也没有，这里就讲一下鄙人粗浅的理解，大概就是在面向对象语言中根据使用场景，合理地安排类、借口之间的封装、继承、多态关系，使得程序开发和运行的效率达到较高。</p>
<blockquote>
<p><strong>设计模式</strong>（design pattern）是对中普遍存在（反复出现）的各种问题，所提出的解决方案。</p>
<div align="right">——来自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">Wikipedia</a></div>
</blockquote>
<h1 id="uml类图"><a class="markdownIt-Anchor" href="#uml类图"></a> UML类图</h1>
<p>本篇博客用到了大量UML类图，我也是刚刚学习UML工具，所以顺便地做一下类图的学习笔记，以免今后遗忘。</p>
<p>本文中的类图，有一部分是来源于互联网，但大部分是自己画的。在这过程中我尝试了许多工具，如Visio、Vscode、draw.io等，所以图像的风格比较多变，最后发现draw.io比较好用，<a target="_blank" rel="noopener" href="http://xn--draw-494f50ai2ckw3cuyvwycj18c.io">于是定下来使用draw.io</a>。</p>
<h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2>
<p><img src="/2024/09/08/Design_Patterns/Singleton.png" srcset="/img/loading.gif" lazyload alt="单例模式示意图"></p>
<h2 id="关系"><a class="markdownIt-Anchor" href="#关系"></a> 关系</h2>
<h3 id="单向关联"><a class="markdownIt-Anchor" href="#单向关联"></a> 单向关联</h3>
<p>一个最简单的箭头表示单向关联，简单地说就是表示has-a的关系。</p>
<p><img src="/2024/09/08/Design_Patterns/uml_association.jpg" srcset="/img/loading.gif" lazyload alt="关联关系"></p>
<h3 id="依赖关系"><a class="markdownIt-Anchor" href="#依赖关系"></a> 依赖关系</h3>
<p>依赖关系表示一种动态的关系，表明一个类在运行时可能会使用到另一个类，与关联关系不同的是，它是一种临时关系。</p>
<p><img src="/2024/09/08/Design_Patterns/uml_dependency.jpg" srcset="/img/loading.gif" lazyload alt="依赖关系"></p>
<h3 id="实现关系"><a class="markdownIt-Anchor" href="#实现关系"></a> 实现关系</h3>
<p>实现关系是用于表达对接口或抽象类的视线，用一个三角箭头+虚线表示。</p>
<p><img src="/2024/09/08/Design_Patterns/uml_realize.jpg" srcset="/img/loading.gif" lazyload alt="实现关系"></p>
<h3 id="继承关系"><a class="markdownIt-Anchor" href="#继承关系"></a> 继承关系</h3>
<p>继承关系用一个三角箭头+实线表示。</p>
<p><img src="/2024/09/08/Design_Patterns/uml_realize-1728011506750-13.jpg" srcset="/img/loading.gif" lazyload alt="继承关系"></p>
<h3 id="聚合关系"><a class="markdownIt-Anchor" href="#聚合关系"></a> 聚合关系</h3>
<p>聚合关系表示一种一对多的关系，带菱形箭头的一边是“多”的关系。与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在。</p>
<p><img src="/2024/09/08/Design_Patterns/uml_aggregation.jpg" srcset="/img/loading.gif" lazyload alt="聚合关系"></p>
<h3 id="组合关系"><a class="markdownIt-Anchor" href="#组合关系"></a> 组合关系</h3>
<p>组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了。</p>
<p><img src="/2024/09/08/Design_Patterns/uml_composition.jpg" srcset="/img/loading.gif" lazyload alt="组合关系"></p>
<h1 id="创建模式"><a class="markdownIt-Anchor" href="#创建模式"></a> 创建模式</h1>
<h2 id="简单工厂模式simple-factory"><a class="markdownIt-Anchor" href="#简单工厂模式simple-factory"></a> 简单工厂模式Simple Factory</h2>
<p>简单工厂模式非常好理解，主要的抽象是由产品类提供的。从产品类中分化出产品A、B、C等，而工厂会根据输入的参数来决定返回何种产品，具体地说，就是输入一个字符串，在工厂的创建方法中使用if语句逐个判断，决定返回何类产品。</p>
<h2 id="工厂方法模式factory-method"><a class="markdownIt-Anchor" href="#工厂方法模式factory-method"></a> 工厂方法模式Factory Method</h2>
<p>工厂方法模式是对简单工厂模式的进一步抽象，简单工厂模式返回何种产品是由输入的参数决定的，这是一种硬编码行为；而工厂方法模式将返回对象的决定权交给工厂类，每个工厂类只会返回特定的产品。</p>
<p><img src="/2024/09/08/Design_Patterns/FactoryMethod.png" srcset="/img/loading.gif" lazyload alt="工厂方法模式示意图"></p>
<h3 id="模式分析"><a class="markdownIt-Anchor" href="#模式分析"></a> 模式分析</h3>
<ul>
<li><strong>隐藏细节</strong>：向客户隐藏了哪种产品将被实例化这一细节，用户只需要关心所需产品对应的工厂，甚至连返回的具体产品类都不需要关注。</li>
<li><strong>可扩展性强</strong>：当需要增加新的产品时，只需要增加具体的工厂类和产品类即可，无须修改客户端。</li>
</ul>
<h2 id="抽象工厂abstract-method"><a class="markdownIt-Anchor" href="#抽象工厂abstract-method"></a> 抽象工厂Abstract Method</h2>
<p><img src="/2024/09/08/Design_Patterns/AbstractFactory.png" srcset="/img/loading.gif" lazyload alt="抽象工厂UML类图"></p>
<p>抽象工厂与工厂方法很类似，但是抽象工厂可以用于产生一系列的产品，强调的是产品的<strong>系列</strong>或<strong>产品族</strong>。</p>
<h3 id="模式分析-2"><a class="markdownIt-Anchor" href="#模式分析-2"></a> 模式分析</h3>
<ul>
<li><strong>分离具体的类</strong>：将客户与类的实现分离，客户只需要与工厂交互，即可产生不同的产品。</li>
<li><strong>易于交换产品系列</strong>：只需要改变具体的工厂即可改变不同的配置，例如：只需要使用A工厂就可以产生A风格的窗口组件，在需要B风格时的组件，改变为B工厂即可。</li>
<li><strong>有利用产品的一致性</strong>：一个应用程序一次只能使用同一个系列的对象，有利于产品一致性。</li>
<li><strong>难以支持新的产品</strong>：抽象工厂确定了可以被创建的产品集合，支持新的产品（例如C类产品）就需要扩展工厂接口，这意味着所有的工厂子类都要改变。</li>
</ul>
<h2 id="建造者builder"><a class="markdownIt-Anchor" href="#建造者builder"></a> 建造者Builder</h2>
<p><img src="/2024/09/08/Design_Patterns/Builder.png" srcset="/img/loading.gif" lazyload alt="Builder"></p>
<p>建造者模式似乎和<strong>策略模式</strong>有些相似，都是定义好调用顺序，而将具体调用的函数决定权交给运行时的对象。不同的是，建造者模式更强调返回的产品，而策略模式强调的是对数据的处理。</p>
<h3 id="模式分析-3"><a class="markdownIt-Anchor" href="#模式分析-3"></a> 模式分析</h3>
<ul>
<li><strong>将构造代码和表示代码分开</strong>：举例说明，当用户需要构建电脑这样复杂而陌生的对象时，很难将所有的部件都正确构造，此时我们使用建造者模式，将指挥者Director交给用户，用户只需要关注Director的方法即可，无须关注具体细节。</li>
<li><strong>对构造过程进行更精细的控制</strong>：指挥者会按顺序构造产品，只有产品完成时才会返回产品。</li>
</ul>
<h2 id="单例模式singleton"><a class="markdownIt-Anchor" href="#单例模式singleton"></a> 单例模式Singleton</h2>
<p>在一些场景下，只允许拥有一个实例变量，例如：在进行加密时，全局只能有一个参数类，否则加解密会出现问题；在操作系统中，也只能拥有一个文件系统。在这些场景中，使用单例模式十分合适。</p>
<p><img src="/2024/09/08/Design_Patterns/Singleton.png" srcset="/img/loading.gif" lazyload alt="单例模式示意图"></p>
<p>在单例模式中，主要思路是将类的构造函数和实例对象声明为私有，想要获得实例，必须通过<code>getInstance</code>方法。而<code>getInstance</code>方法正是用于管理“单例”的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Singleton* <span class="hljs-title">Singleton::getInstance</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">NULL</span>)<br>	&#123;<br>		instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span>  instance;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1 id="构造型模式"><a class="markdownIt-Anchor" href="#构造型模式"></a> 构造型模式</h1>
<h2 id="适配器模式adapter"><a class="markdownIt-Anchor" href="#适配器模式adapter"></a> 适配器模式Adapter</h2>
<p>适配器模式在思维上很简单，类似插座的转接，由于每个国家对插座的标准制定的不一样，所以用户在使用另一个国家的插座时便不得不使用这样的一个转接口来进行转接。在非面向对象的语言中，可能也存在着这样的设计思想，就是把第三方库或调用方式复杂的内容重新封装后暴露给用户。</p>
<p><img src="/2024/09/08/Design_Patterns/6477d44a8ed781508.jpg_e1080.jpg" srcset="/img/loading.gif" lazyload alt="适配器模式"></p>
<p>适配器模式可以分为<strong>对象适配器和类适配器</strong>，具体的继承和组合关系如下图。</p>
<p><img src="/2024/09/08/Design_Patterns/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.drawio.png" srcset="/img/loading.gif" lazyload alt="对象适配器"></p>
<p><img src="/2024/09/08/Design_Patterns/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.drawio.png" srcset="/img/loading.gif" lazyload alt="类适配器模式"></p>
<p>两种适配器模式的区别，仅是Adapter以什么方式通知Adaptee的区别。</p>
<h3 id="模式分析-4"><a class="markdownIt-Anchor" href="#模式分析-4"></a> 模式分析</h3>
<ul>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。</li>
</ul>
<h3 id="辨析类适配器模式和对象适配器模式"><a class="markdownIt-Anchor" href="#辨析类适配器模式和对象适配器模式"></a> 辨析类适配器模式和对象适配器模式</h3>
<p>对象适配器模式可以组合多个被适配者，使用起来功能更强大，也更简单；类适配器可以重写被适配者的方法，使用起来更加灵活。对象适配器很难置换适配者的方法，需要通过继承自原适配者来实现，操作起来较麻烦；而类适配器对象无法在不支持多继承的语言中实现。</p>
<h2 id="外观模式facade"><a class="markdownIt-Anchor" href="#外观模式facade"></a> 外观模式Facade</h2>
<p>外观模式和适配器模式十分相似，都是用于封装。但不同的是，适配器模式强调的是对旧接口或者第三方接口的改变，使其适应新的接口；而外观模式强调的是对复杂系统的整合，使得客户只能接触到简单的系统。</p>
<p><img src="/2024/09/08/Design_Patterns/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.drawio.png" srcset="/img/loading.gif" lazyload alt="外观模式.drawio"></p>
<p>外观模式的UML类图看起来还是很简单的，所见即所得。</p>
<h3 id="模式分析-5"><a class="markdownIt-Anchor" href="#模式分析-5"></a> 模式分析</h3>
<p>外观模式虽然简单，但是在程序设计中却十分重要。首先，在软件系统中将一个大型系统分割为多个小型系统有利于使系统之间的通信和相互依赖达到最小，遵循的是<strong>单一职责原则</strong>。其次，外观模式可以降低客户和内部复杂系统的耦合性。最后，外观模式也是<strong>迪米特</strong>原则的体现，即最小知识原则。</p>
<p>但是，外观模式也有一定的缺点，例如，如果要增加新的子系统，则需要对外观类进行修改。</p>
<h2 id="桥接模式bridge"><a class="markdownIt-Anchor" href="#桥接模式bridge"></a> 桥接模式Bridge</h2>
<h3 id="问题场景"><a class="markdownIt-Anchor" href="#问题场景"></a> 问题场景</h3>
<p>理解桥接模式首先需要了解桥接模式为了解决什么样的问题。设想这样一种情况：汽车分有许多种类，包含SUV、轿车、跑车等，而这些种类又有许多种品牌，例如奔驰、宝马、奥迪等。实现这样的一个场景，最容易想到的方法就是设计一个抽象父类Car，接下来由三个<strong>抽象的子类</strong>奔驰、宝马、奥迪继承，每个抽象子类再由SUV、轿车、跑车继承，形成一种树形结构。这样的设计模式在汽车种类、品牌种类少的情况下还可以使用，然而当品牌和汽车种类变多时，就会发生子类爆炸的情况，最多需要实现<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m*n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>个子类，维护变得十分困难。</p>
<p>桥接方式是使用了类似<strong>笛卡尔积</strong>的方式来实现这种场景，既然汽车可以从具体的<strong>种类</strong>和抽象的<strong>品牌</strong>上分出来两个维度，那我们将种类设计为抽象类，品牌设计为接口，就可以较为简单地实现上述场景。</p>
<p><img src="/2024/09/08/Design_Patterns/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.drawio.png" srcset="/img/loading.gif" lazyload alt="桥接模式.drawio"></p>
<p>关于设计时将哪个维度设计为接口，哪个维度设计为抽象类，根据ChatGPT的建议，将变化频繁的维度设计为接口更加合适，并且如果有一个维度需要共享一些数据，则将这个维度设计为抽象类。<em>在实际设计中，右边的接口也可以设计为抽象类。</em></p>
<h3 id="模式分析-6"><a class="markdownIt-Anchor" href="#模式分析-6"></a> 模式分析</h3>
<p>桥接模式可以看成是多继承（特别是两层继承）的一种替代，可以大大减少类的数量，并且只需要较少的修改就可以增加一系列的类。但是桥接模式的缺点也很明显，桥接模式的理解和设计的难度较大，需要程序员去主动“发现”两个维度，对程序员的要求较高。</p>
<h2 id="装饰器模式decorator"><a class="markdownIt-Anchor" href="#装饰器模式decorator"></a> 装饰器模式Decorator</h2>
<p>装饰器模式某种意义上缓解了继承的滥用。众所周知，在面向对象语言中，一个类的所有父类，在编译时就已经确定了。或者更具体地说，如果使用继承来描述类之间的关系，那么继承链在编译时就确定了，运行时不能进行修改，很大地限制了灵活性和可扩展性。</p>
<p>装饰器模式下的关键对象，可以分为<strong>组件（Component）<strong>和</strong>装饰者（Decorator）</strong>。下面是装饰器模式的示意图（个人任务，打叉的那条线不要画更容易理解）。<em>之后的例子中可以看到，装饰者在使用上和组件没有差异</em>。参考书中用于阐述装饰器模式的例子是咖啡，为了更好地本土化，本文采用奶茶来理解。</p>
<p><img src="/2024/09/08/Design_Patterns/image-20240911114704046.png" srcset="/img/loading.gif" lazyload alt="装饰器模式示意图"></p>
<p>组件可以理解为只包含茶底的奶茶，装饰者可以理解为加了小料后的奶茶。可以看到，Decorator类中会有一个实例变量记录被装饰者，所以<code>Decorator</code>类中可以包含所有<code>Component</code>类的子类，<strong>包括<code>Decorator</code>类自己</strong>。由此，装饰者就可以互相嵌套，并且突破了继承关系的次序限制。</p>
<p>在调用最外层的装饰者的方法时，会逐层调用相应的方法，并根据每一层装饰者的特性对上一层的数据进行处理。</p>
<p>在为装饰者添加了合适的构造函数时，还可以用非常简单的语法来嵌套装饰者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">MilkTea my_favorite = <span class="hljs-keyword">new</span> Sugar(<span class="hljs-keyword">new</span> Milk(<span class="hljs-keyword">new</span> Tea(<span class="hljs-keyword">new</span> Traditional)));<br></code></pre></td></tr></table></figure>
<h3 id="典型实践"><a class="markdownIt-Anchor" href="#典型实践"></a> 典型实践</h3>
<p>java的IO包中的输入输出流就是用装饰器模式来设计的。以输入流模式为例，其父类是<code>InputStream</code>，在实际的编程中，我们可以根据场景来实例化不同的Stream，而不需要管手上原有的Stream到底是什么。</p>
<p><img src="/2024/09/08/Design_Patterns/a77bb4adfad84fa6bcf8c5026ae37afftplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" srcset="/img/loading.gif" lazyload alt="Java中的装饰器模式"></p>
<h2 id="享元模式flyweight"><a class="markdownIt-Anchor" href="#享元模式flyweight"></a> 享元模式Flyweight</h2>
<p>享元模式的应用场景似乎比较少，这里就简单介绍一下。享元模式的思想是，如果程序中用到大量重复的对象，就不再重复创建新的对象，而是使用<strong>享元工厂</strong>来获取。享元工厂会维护一个Hash表，当发现当前需要创建的对象在内存中已经存在时，就直接返回这个对象。实际上，“重复的对象”并不是非要完全相同，在设计时可以分离出对象的不可变的<strong>内部状态</strong>和可变的<strong>外部状态</strong>，将内部状态作为享元来使用。</p>
<h3 id="典型实践-2"><a class="markdownIt-Anchor" href="#典型实践-2"></a> 典型实践</h3>
<p>享元模式在Java标准库中大量使用，对Integer进行封装时，没有必要对所有的Integer都创建一个对象进行包装，而是将-127~128之间的Integer提前创建好对象放置在内存中，需要这个范围内的包装时，就直接返回内存中的实例。</p>
<p>另一个典型场景就是各种编辑器软件，例如，一个文档中，若同样的图片出现多次，就没有必要为其创建多个相同的对象，而是将图片的数据作为内部对象储存，将图片的外在格式（如大小、位置）等信息作为外部对象。</p>
<h1 id="行为型模式"><a class="markdownIt-Anchor" href="#行为型模式"></a> 行为型模式</h1>
<h2 id="观察者模式observer"><a class="markdownIt-Anchor" href="#观察者模式observer"></a> 观察者模式Observer</h2>
<p><strong>观察者模式</strong>可以类比成对报纸、杂志的订阅，当报社有新一期的报纸出版时，就会向所有订阅该报纸的用户发送通知，而未订阅报纸的用户则不会接收到通知。所以观察者模式的两个关键对象就是<strong>出版者</strong>和<strong>订阅者</strong>，或者更学术地，<strong>主题（Subject）<strong>和</strong>观察者（Observer）</strong></p>
<p>观察者模式的思路十分简单，从编程语言的角度，主题对象中会有一个存储所有观察者的数据结构，观察者也会记录自己所订阅的主题，当观察者开始新的订阅或取消订阅时，主题对象就修改自己的数据结构。而当主题对象的某事件（通常是数据变化）触发时，就会逐个通知所有订阅的观察者。通常，<strong>观察者需要实现某个接口函数（如：<code>update()</code>）</strong>，以便让观察者调用。</p>
<p>观察者模式又可以细分为两种，“推”和“拉”。</p>
<h3 id="推"><a class="markdownIt-Anchor" href="#推"></a> “推”</h3>
<p>在这种模式下，主题是主动的。主题会调用观察者的<code>update(param ...)</code>来将所有数据通过参数来传递给观察者。这种方法可以一次性传递所有数据，但是在不同观察者所需的数据不同时，会向观察者一些不需要的信息。</p>
<h3 id="拉"><a class="markdownIt-Anchor" href="#拉"></a> “拉”</h3>
<p>这种模式是由观察者主动的，主题调用观察者的<code>update()</code>方法通知观察者后，观察者还需要调用主题的Getter来主动地获取数据，这种模式灵活性较高。</p>
<h2 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h2>
<p>当我们需要向一个对象发送命令或请求，但是不知道命令的接收者是谁（要等到运行时才能知道）时，就可以使用命令模式。命令模式实际上就是将请求的信息封装成一个对象，将其与发送者、接收者解耦，同时，也将发送者与接收者解耦。一个比较好理解的例子就是遥控器。</p>
<p><img src="/2024/09/08/Design_Patterns/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.drawio.png" srcset="/img/loading.gif" lazyload alt="命令模式"></p>
<h3 id="模式分析-7"><a class="markdownIt-Anchor" href="#模式分析-7"></a> 模式分析</h3>
<ul>
<li>每一个命令都是一个操作，并且有明确的接收者和发送者。</li>
<li>命令模式使得每个命令都成为对象，使得命令可以被存储和传递，在一些编辑器软件中也使得用户可以进行撤销和重做。</li>
<li>命令模式还可以将多个命令组合起来形成一个宏命令，或者是命令队列。</li>
</ul>
<h2 id="中介者模式mediator"><a class="markdownIt-Anchor" href="#中介者模式mediator"></a> 中介者模式Mediator</h2>
<p>当系统结构复杂时，对象之间可能会存在着大量的相互引用，这样会使得系统的耦合性很强。举个例子，就是网络聊天室。如果希望用户之间可以互相发消息，则需要每个用户都保留着对其他用户的引用，这样需要维护大量的用户状态，使得系统十分复杂。所以，我们非常自然地想到引入一个<strong>中介者</strong>来代为管理，这些用户则被称为<strong>同事类</strong></p>
<p>在中介者模式中，同事类只知道中介者的存在，知道如何想向中介者发送通知或改变状态，而不知道其他同事的存在。这样的模式就大大降低了同事对象之间的耦合度。</p>
<p><img src="/2024/09/08/Design_Patterns/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.drawio.png" srcset="/img/loading.gif" lazyload alt="中介者模式"></p>
<p>中介者模式的UML类图如上，实际上，在简单的系统中，两个抽像类的存在都不是必要的。</p>
<h3 id="模式分析-8"><a class="markdownIt-Anchor" href="#模式分析-8"></a> 模式分析</h3>
<p>中介者模式可以简化对象之间的交互，将各个同事解耦，在特定情况下可以大大降低各个同事类之间的耦合程度。但是，中介者类包含了同事之间的交互细节，可能会导致中介者类非常复杂，使得系统难以维护。</p>
<h2 id="状态模式state"><a class="markdownIt-Anchor" href="#状态模式state"></a> 状态模式State</h2>
<p>状态模式大致的思路就是将状态设计为抽象类，并作为一个成员变量放到上下文对象中。这样一来，在修改状态的同时也可以修改上下文的行为。</p>
<p><img src="/2024/09/08/Design_Patterns/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.drawio.png" srcset="/img/loading.gif" lazyload alt="状态模式.drawio"></p>
<h3 id="模式分析-9"><a class="markdownIt-Anchor" href="#模式分析-9"></a> 模式分析</h3>
<p>状态模式封装了转换规则，在切换状态时便可以自动改变上下文对象的相应字段和行为（可以将行为放在状态中），减少了状态之间切换的复杂度。这样的设计还将状态转换逻辑与状态对象合为一体，而不是一个巨大的条件语句块。</p>
<h2 id="策略模式strategy"><a class="markdownIt-Anchor" href="#策略模式strategy"></a> 策略模式Strategy</h2>
<p>策略模式理解起来很简单，只要结合一个实例即可，那就是排序算法。在C++、Java的标准库中，都提供了排序算法，用户可以向其传入参数来决定元素之间的对比策略，这里用到的就是策略模式。更宽泛地说，策略模式将程序执行过程中的控制流封装成了对象，以方便替换，就像搭积木一样。</p>
<p><img src="/2024/09/08/Design_Patterns/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.drawio.png" srcset="/img/loading.gif" lazyload alt="策略模式"></p>
<h1 id="设计模式总结"><a class="markdownIt-Anchor" href="#设计模式总结"></a> 设计模式总结</h1>
<p>在设计面向对象程序时，经常会纠结“这个方法放到哪个类中”“如何使用类的继承和组合关系”这样类似的问题，设计模式就是解决这类问题的范式。合理地运用设计模式可以降低程序之间的耦合性，简化开发难度。然而，正如《Head First 设计模式》中提到的那样，设计模式的运用不是必要的。当开发一个简单的系统时，不必要地使用设计模式可能会让代码变得很复杂。这也是在学习设计模式时，看到代码总会想“这么做难道不是更复杂了？”的原因，因为简单的系统中，直接使用最自然的思路就是最好的。</p>
<p>所以学习设计模式，并不是要把所有设计模式学通，然后想方设法在程序中应用它。而是学习设计模式是如何通过继承和组合等关系来解决问题，如何降低程序的耦合性，如何设计出优雅的程序。希望通过这段时间的学习，对我的程序开发能力有所帮助。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>
              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%BC%80%E5%8F%91/" class="category-chain-item">开发</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">#编程语言</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>设计模式学习笔记</div>
      <div>http://zhouhf.top/2024/09/08/Design_Patterns/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>周洪锋</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月8日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/10/11/Json-Parser/" title="【项目心得】使用C语言写一个Json解析器">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【项目心得】使用C语言写一个Json解析器</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/22/html-css%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="html+css学习笔记">
                        <span class="hidden-mobile">html+css学习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.7.2/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"Ov23liudPNomhUyrQIaq","clientSecret":"a9de1582a206aabfd5adb8a409d1689a5d447856","repo":"zhf999.github.io","owner":"zhf999","admin":["zhf999"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'ad019a90551228af5c30dd7bd482850c'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
